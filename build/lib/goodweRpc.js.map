{
  "version": 3,
  "sources": ["../../src/lib/goodweRpc.ts"],
  "sourcesContent": ["\uFEFFimport { spawn } from 'node:child_process';\nimport type { ChildProcessWithoutNullStreams } from 'node:child_process';\nimport * as readline from 'node:readline';\n\ntype RpcResponse = { id: number; ok: true; data: unknown } | { id: number; ok: false; error: string };\n\n/**\n *\n */\nexport interface SensorMeta {\n    /**\n     *\n     */\n    id: string;\n    /**\n     *\n     */\n    name: string;\n    /**\n     *\n     */\n    unit?: string;\n}\n\n/**\n * JSON-RPC-like client that communicates with a persistent Python worker process.\n */\nexport class GoodweRpc {\n    private proc?: ChildProcessWithoutNullStreams;\n    private rl?: readline.Interface;\n    private nextId = 1;\n\n    private readonly pending = new Map<\n        number,\n        {\n            resolve: (v: unknown) => void;\n            reject: (e: Error) => void;\n        }\n    >();\n\n    /**\n     * @param pythonExe Path to the Python executable (e.g. venv python).\n     * @param scriptPath Path to the `goodwe_rpc.py` script.\n     * @param args Arguments passed to the Python worker.\n     */\n    public constructor(\n        private readonly pythonExe: string,\n        private readonly scriptPath: string,\n        private readonly args: string[],\n    ) {}\n\n    /**\n     *\n     */\n    public start(): void {\n        this.proc = spawn(this.pythonExe, [this.scriptPath, ...this.args], { stdio: ['pipe', 'pipe', 'pipe'] });\n\n        this.proc.on('exit', code => {\n            const err = new Error(`Python worker exited with code ${code}`);\n            for (const [, p] of this.pending) {\n                p.reject(err);\n            }\n            this.pending.clear();\n        });\n\n        this.rl = readline.createInterface({ input: this.proc.stdout });\n        this.rl.on('line', line => {\n            try {\n                const msg = JSON.parse(line) as RpcResponse;\n                const p = this.pending.get(msg.id);\n                if (!p) {\n                    return;\n                }\n                this.pending.delete(msg.id);\n\n                if (msg.ok) {\n                    p.resolve(msg.data);\n                } else {\n                    p.reject(new Error(msg.error));\n                }\n            } catch {\n                // Ignore malformed output lines from the worker\n            }\n        });\n    }\n\n    /**\n     *\n     */\n    public stop(): void {\n        this.rl?.close();\n        this.proc?.kill();\n    }\n\n    private call(cmd: string, value?: unknown): Promise<unknown> {\n        if (!this.proc?.stdin.writable) {\n            return Promise.reject(new Error('Python worker not running'));\n        }\n\n        const id = this.nextId++;\n        const payload: Record<string, unknown> = { id, cmd };\n        if (value !== undefined) {\n            payload.value = value;\n        }\n\n        const p = new Promise<unknown>((resolve, reject) => {\n            this.pending.set(id, { resolve, reject });\n        });\n\n        this.proc.stdin.write(`${JSON.stringify(payload)}\\n`);\n        return p;\n    }\n\n    /**\n     *\n     */\n    public async getSensors(): Promise<SensorMeta[]> {\n        return (await this.call('get_sensors')) as SensorMeta[];\n    }\n\n    /**\n     *\n     */\n    public async readRuntime(): Promise<Record<string, unknown>> {\n        return (await this.call('read_runtime')) as Record<string, unknown>;\n    }\n\n    /**\n     *\n     */\n    public async getMinSoc(): Promise<{ min_soc: number; ongrid_dod: number }> {\n        return (await this.call('get_min_soc')) as { min_soc: number; ongrid_dod: number };\n    }\n\n    /**\n     *\n     */\n    public async setMinSoc(minSoc: number): Promise<unknown> {\n        return this.call('set_min_soc', minSoc);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAC,gCAAsB;AAEvB,eAA0B;AAyBnB,MAAM,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBZ,YACc,WACA,YACA,MACnB;AAHmB;AACA;AACA;AAAA,EAClB;AAAA,EArBK;AAAA,EACA;AAAA,EACA,SAAS;AAAA,EAEA,UAAU,oBAAI,IAM7B;AAAA;AAAA;AAAA;AAAA,EAgBK,QAAc;AACjB,SAAK,WAAO,iCAAM,KAAK,WAAW,CAAC,KAAK,YAAY,GAAG,KAAK,IAAI,GAAG,EAAE,OAAO,CAAC,QAAQ,QAAQ,MAAM,EAAE,CAAC;AAEtG,SAAK,KAAK,GAAG,QAAQ,UAAQ;AACzB,YAAM,MAAM,IAAI,MAAM,kCAAkC,IAAI,EAAE;AAC9D,iBAAW,CAAC,EAAE,CAAC,KAAK,KAAK,SAAS;AAC9B,UAAE,OAAO,GAAG;AAAA,MAChB;AACA,WAAK,QAAQ,MAAM;AAAA,IACvB,CAAC;AAED,SAAK,KAAK,SAAS,gBAAgB,EAAE,OAAO,KAAK,KAAK,OAAO,CAAC;AAC9D,SAAK,GAAG,GAAG,QAAQ,UAAQ;AACvB,UAAI;AACA,cAAM,MAAM,KAAK,MAAM,IAAI;AAC3B,cAAM,IAAI,KAAK,QAAQ,IAAI,IAAI,EAAE;AACjC,YAAI,CAAC,GAAG;AACJ;AAAA,QACJ;AACA,aAAK,QAAQ,OAAO,IAAI,EAAE;AAE1B,YAAI,IAAI,IAAI;AACR,YAAE,QAAQ,IAAI,IAAI;AAAA,QACtB,OAAO;AACH,YAAE,OAAO,IAAI,MAAM,IAAI,KAAK,CAAC;AAAA,QACjC;AAAA,MACJ,QAAQ;AAAA,MAER;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKO,OAAa;AAzFxB;AA0FQ,eAAK,OAAL,mBAAS;AACT,eAAK,SAAL,mBAAW;AAAA,EACf;AAAA,EAEQ,KAAK,KAAa,OAAmC;AA9FjE;AA+FQ,QAAI,GAAC,UAAK,SAAL,mBAAW,MAAM,WAAU;AAC5B,aAAO,QAAQ,OAAO,IAAI,MAAM,2BAA2B,CAAC;AAAA,IAChE;AAEA,UAAM,KAAK,KAAK;AAChB,UAAM,UAAmC,EAAE,IAAI,IAAI;AACnD,QAAI,UAAU,QAAW;AACrB,cAAQ,QAAQ;AAAA,IACpB;AAEA,UAAM,IAAI,IAAI,QAAiB,CAAC,SAAS,WAAW;AAChD,WAAK,QAAQ,IAAI,IAAI,EAAE,SAAS,OAAO,CAAC;AAAA,IAC5C,CAAC;AAED,SAAK,KAAK,MAAM,MAAM,GAAG,KAAK,UAAU,OAAO,CAAC;AAAA,CAAI;AACpD,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,aAAoC;AAC7C,WAAQ,MAAM,KAAK,KAAK,aAAa;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,cAAgD;AACzD,WAAQ,MAAM,KAAK,KAAK,cAAc;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,YAA8D;AACvE,WAAQ,MAAM,KAAK,KAAK,aAAa;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,UAAU,QAAkC;AACrD,WAAO,KAAK,KAAK,eAAe,MAAM;AAAA,EAC1C;AACJ;",
  "names": []
}
